## 정렬
정렬은 배열을 크기 순으로 오름차순이나 내림차순으로 나열하는 것을 의미한다. 정렬은 아주 기본적이고 중요한 알고리즘으로 많은 종류의 정렬 알고리즘이 존재한다. 자바스크립트에는 내장된 메서드로 sort를 제공한다.
```javascript
let arr = [2, 1, 3];
arr.sort();
console.log(arr); // 출력값 : [1, 2, 3]
```
이 경우에는 내림차순의 정렬이 불가능하고 정렬하는 요소들의 크기보단 문자로서의 순서를 우선시하기 때문에 다음과 같은 현상이 생긴다.
```javascript
let arr = [2, 1, 3, 11];
arr.sort();
console.log(arr); // 출력값 : [1, 11, 2, 3]
```

하지만 아예 방법이 존재하지 않는 것은 아니다. sort의 매개변수에 함수를 입력하면 여러 형태로 정렬을 할 수가 있다.
```javascript
let arr = [2, 1, 3, 11];
arr.sort((a,b)=>a-b);
console.log(arr); // 출력값 : [1, 2, 3, 11]

arr.sort((a,b)=>b-a);
console.log(arr); // 출력값 : [11, 3, 2, 1]
```
### Selection sort (선택 정렬)

선택 정렬은 가장 이해하기 쉬운 정렬 방법으로, 반복을 거치며 가장 작은 (혹은 가장 큰) 선택하여 쌓아가는 정렬 방법이다.
> [5, 3, 8, 1, 2, 7]

위와 같은 배열을 선택 정렬로 정렬해보면서 구조를 살펴보자. 오름차순으로 정렬을 할 때, 가장 작은 요소를 찾아 0번 인덱스의 값과 자리를 바꾸고 다음 인덱스로 옮겨가는 반복을 (배열의 길이 - 1)번 만큼 반복한다.
>[5, 3, 8, 1, 2, 7][
[**~~1~~**, 3, 8, **5**, 2, 7] => Pass 1
[~~1, **2**~~, 8, 5, **3**, 7] => Pass 2
[~~1, 2, **3**~~, 5, **8**, 7] => Pass 3
[~~1, 2, 3, **5**~~, 8, 7] => Pass 4
[~~1, 2, 3, 5, **7**~~, **8**] => Pass 5



### Insertion sort (삽입 정렬)

삽입 정렬은 반복을 돌며 만나는 요소를 정렬된 부분의 들어갈 자리에 삽입하며 나아가는 정렬 방식이다.
>[5, 3, 8, 1, 2, 7][
[~~**3**, 5~~, 8, 1, 2, 7] => Pass 1
[~~3, 5, **8**~~, 1, 2, 7] => Pass 2
[~~**1**, 3, 5, 8~~, 2, 7] => Pass 3
[~~1, **2**, 3, 5, 8~~, 7] => Pass 4
[~~1, 2, 3, 5, **7**, 8~~] => Pass 5

### Bubble sort (버블 정렬)

버블 정렬은 인접한 2개의 요소를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환하는 비교-교환 과정을 배열의 0번 인덱스부터 마지막 인덱스까지 진행한다. 이런 비교-교환 과정이 한 번 지나면 가장 큰(혹은 작은) 요소가 배열의 가장 오른쪽으로 이동한다. 이런 과정을 (배열의 길이 - 1)번 만큼 반복하면 정렬이 완성된다.
>[5, 3, 8, 1, 2, 7]
>
// Pass 1 과정
>[**3**, **5**, 8, 1, 2, 7][
>[3, **5**, **8**, 1, 2, 7][
[3, 5, **1**, **8**, 2, 7][
[3, 5, 1, **2**, **8**, 7][
[3, 5, 1, 2, **7**, **8**]

>[3, 5, 1, 2, 7, ~~8~~] => Pass 1
[3, 1, 2, 5, ~~7, 8~~] => Pass 2
[1, 2, 3, ~~5, 7, 8~~] => Pass 3
[1, 2, ~~3, 5, 7, 8~~] => Pass 4
[~~1, 2, 3, 5, 7, 8~~] => Pass 5

### Shell sort (쉘 정렬)

쉘 정렬은 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른 것에서 착안한 방법이다. 삽입 정렬의 최대 문제점은 요소들이 삽입될 때, 이웃한 위치로만 이동한다는 것이다. 쉘 정렬은 간격을 벌려놓고 그 간격마다 있는 요소끼리 정렬을 하며 배열을 합쳐준다.
> [10, 8, 6, 20, 4, 3, 22, 1, 0, 15, 16]
>
// Pass 1 과정
10 ㅁ ㅁ ㅁ ㅁ 3 ㅁ ㅁ ㅁ ㅁ 16
ㅁ 8 ㅁ ㅁ ㅁ ㅁ 22 
ㅁ ㅁ 6 ㅁ ㅁ ㅁ ㅁ 1
ㅁ ㅁ ㅁ 20 ㅁ ㅁ ㅁ ㅁ 0
ㅁ ㅁ ㅁ ㅁ 4 ㅁ ㅁ ㅁ ㅁ 15
>
// 정해진 간격끼리의 요소끼리 정렬
3 ㅁ ㅁ ㅁ ㅁ 10 ㅁ ㅁ ㅁ ㅁ 16
ㅁ 8 ㅁ ㅁ ㅁ ㅁ 22
ㅁ ㅁ 1 ㅁ ㅁ ㅁ ㅁ 6
ㅁ ㅁ ㅁ 0 ㅁ ㅁ ㅁ ㅁ 20
ㅁ ㅁ ㅁ ㅁ 4 ㅁ ㅁ ㅁ ㅁ 15
[3, 8, 1, 0, 4, 10, 22, 6, 20, 15, 16]

한 번 정렬이 끝나고 나면 다음 Pass에서 간격을 1/2 로 줄여서 정렬을 진행한다.
> [3, 8, 1, 0, 4, 10, 22, 6, 20, 15, 16] => Pass 1
[0, 4, 1, 3, 6, 10, 15, 8, 20, 22, 16] => Pass 2
[0, 1, 3, 4, 6, 8, 10, 15, 16, 20, 22] => Pass 3


### Merge sort (병합 정렬)
병합 정렬은 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트를 얻고자 하는 방법이다. 

>[27, 10, 12, 20, 25, 13, 15, 22]
> 분할
[27, 10, 12, 20] / [25, 13, 15, 22]
분할
[27, 10] / [12, 20] / [25, 13] / [15, 22]
분할
[27] / [10] / [12] / [20] / [25] / [13] / [15] / [22]
병합
[10, 27] / [12, 20] / [13, 25] / [15, 22]
병합
[10, 12, 20, 27] / [13, 15, 22, 25]
병합
[10, 12, 13, 15, 20, 22, 25, 27]

### Quick sort (퀵 정렬)

퀵정렬은 리스트를 비균등하게 분할한 다음 리스트 안에 있는 한 요소를 피벗으로 선택하고 피벗보다 작은 요소를 왼쪽으로 옮기고 큰 요소를 오른쪽으로 옮긴다. 이 상태에서 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬하게 되면 전체 리스트가 정렬된다.

>[5, 3, 8, 4, 9, 1, 6, 2, 7]
> 5 : pivot / left : 3 / right : 7

위의 배열에서 첫 번째 요소인 5를 피벗으로 삼고 왼쪽 끝과 오른쪽 끝에서 출발하여 왼쪽 수는 5보다 작은 지 확인하고 오른쪽 수는 5보다 큰 지를 확인하여 조건에 맞는다면 인덱스를 좁히고 조건에 맞지 않는다면 왼쪽과 오른쪽 수를 바꾸어준다. 인덱스가 좁혀지다가 left와 right의 인덱스가 교차되어 지나가면 pivot과 왼쪽에 쌓인 수 중 가장 오른쪽에 위치한 수를 교체해준다.
>// Pass 1 과정
[**5**, 3, 8, 4, 9, 1, 6, 2, 7][
[5, 3, **2**, 4, 9, 1, 6, **8**, 7][
[5, 3, 2, 4, **1**, **9**, 6, 8, 7][
[**1**, 3, 2, 4, **5**, 9, 6, 8, 7]

Pass 1 과정이 끝나면 왼쪽 리스트와 오른쪽 리스트에 각각 피벗을 새로 선정하여 정렬을 진행한다.


### Radix sort (기수 정렬)
앞서 살펴 본 정렬 방법들은 모두 레코드를 비교하여 정렬한다. 따라서 비교가 불가능한 레코드들은 정렬할 수가 없다. 기수 정렬은 레코드를 비교하지 않고도 정렬하는 방법이다. 다만 기수 정렬은 추가적인 메모리를 필요로 한다. 각 자리수가 0에서 9까지의 값만 가지는 것을 생각하면 10개의 공간을 만들어 입력 데이터 값에 따라 공간에 넣어 정렬을 할 수 있다. 
> [8, 2, 7, 3, 5]
>
0 : 
1 : 
2 : 2
3 : 3
4 : 
5 : 5
6 : 
7 : 7
8 : 8
9 : 
=> [2, 3, 5, 7, 8]

그렇다면 여러 자리로 이루어진 수는 어떻게 정렬할까? 바로 낮은 자리수 먼저 정렬한 다음 차츰 높은 자리수를 정렬하면 가능하다.
>[28, 93, 39, 81, 62, 72, 38, 26]
>
// Pass 1  ---> 일의 자리수 정렬
0 : 
1 : 81
2 : 62, 72
3 : 93
4 : 
5 : 
6 : 26
7 : 
8 : 28, 38
9 : 39
=> [81, 62, 72, 93, 26, 28, 38, 39]
>
// Pass 2 ---> 십의 자리수 정렬
0 : 
1 : 
2 : 26, 28
3 : 38, 39
4 : 
5 : 
6 : 62
7 : 72
8 : 81
9 : 93
=> [26, 28, 38, 39, 62, 72, 81, 93]

### 정렬 알고리즘 비교
|알고리즘|최선|평균|최악|
|------|---|---|---|
|삽입 정렬|O(n)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
|선택 정렬|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
|버블 정렬|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
|쉘 정렬|O(n)|O(n<sup>1.5</sup>)|O(n<sup>1.5</sup>)|
|병합 정렬|O(nLog<sub>2</sub>n)|O(nLog<sub>2</sub>n)|O(nLog<sub>2</sub>n)|
|퀵 정렬|O(nLog<sub>2</sub>n)|O(nLog<sub>2</sub>n)|O(n<sup>2</sup>)|
|기수 정렬|O(dn)|O(dn)|O(dn)|
